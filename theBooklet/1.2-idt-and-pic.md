# Chapter 1.2 — Interrupts: IDT & the PIC

---

## What is an Interrupt?

An **interrupt** is a signal that tells the CPU: stop what you're doing, save your state, and run a specific piece of code called an **Interrupt Service Routine (ISR)**. When the ISR finishes, the CPU restores its state and resumes where it left off.

There are three categories:

| Category | Trigger | Examples |
|----------|---------|---------|
| **Exceptions** | CPU internally detects a fault | Divide by zero, Page Fault, GPF |
| **Hardware IRQs** | External hardware signals | Keyboard, mouse, timer, NIC |
| **Software interrupts** | `int N` instruction | System calls (`int 0x80`), BIOS |

---

## The Interrupt Descriptor Table (IDT)

Just as the GDT tells the CPU about memory segments, the **IDT** tells the CPU where to find each interrupt handler. It is an array of up to **256 gate descriptors**, each 8 bytes, indexed by **interrupt vector number**.

### Gate Types

| Type | Behaviour | Use for |
|------|-----------|---------|
| **Interrupt Gate** | Calls ISR, automatically clears `IF` flag (disables further interrupts) | Hardware IRQs, most exceptions |
| **Trap Gate** | Calls ISR, leaves `IF` flag unchanged | System calls (where nesting is OK) |
| Task Gate | Switches to a TSS | Rarely used — we can ignore this |

### Gate Descriptor Layout

```
Bit:  63               48 47 46 45 44 43  40 39    32
      +-----------------+--+-----+--+------+--------+
      |  Offset [16:31] |P |DPL  |S | Type |  (0)   |
      +-----------------+--+-----+--+------+--------+

Bit:  31               16 15                        0
      +-----------------+---------------------------+
      |    Selector      |      Offset [0:15]        |
      +-----------------+---------------------------+
```

| Bits  | Field         | Meaning |
|-------|---------------|---------|
| 0–15  | Offset[0:15]  | Low 16 bits of ISR handler address |
| 16–31 | Selector      | Code segment for the ISR — always `0x0008` (kernel CS) |
| 32–39 | Reserved      | Always zero |
| 40–43 | Type          | `0xE` = 32-bit interrupt gate, `0xF` = 32-bit trap gate |
| 44    | S             | 0 for interrupt/trap gates |
| 45–46 | DPL           | Privilege required to call via `int N` (0 = kernel only) |
| 47    | P             | Present — must be 1 |
| 48–63 | Offset[16:31] | High 16 bits of ISR handler address |

### The IDTR Register

Like the GDT, the IDT is loaded with a dedicated instruction: **`lidt`**. The IDTR structure is identical to the GDTR — a 16-bit limit followed by a 32-bit base address.

After `lidt`, interrupts remain disabled until you execute **`sti`** (Set Interrupt Flag). Don't call `sti` until the IDT is fully populated **and** the PIC is configured.

---

## CPU Exception Vectors (0–31)

Vectors 0–31 are reserved by Intel for CPU exceptions. You must install a handler for all of them — even if it just halts or prints an error.

| Vector | Mnemonic | Description | Error Code? |
|--------|----------|-------------|-------------|
| 0  | #DE | Divide Error | No |
| 1  | #DB | Debug | No |
| 2  | —   | Non-Maskable Interrupt (NMI) | No |
| 3  | #BP | Breakpoint | No |
| 4  | #OF | Overflow | No |
| 5  | #BR | Bound Range Exceeded | No |
| 6  | #UD | Invalid Opcode | No |
| 7  | #NM | Device Not Available | No |
| 8  | #DF | Double Fault | Yes (always 0) |
| 10 | #TS | Invalid TSS | Yes |
| 11 | #NP | Segment Not Present | Yes |
| 12 | #SS | Stack-Segment Fault | Yes |
| 13 | #GP | General Protection Fault | Yes |
| 14 | #PF | Page Fault | Yes |
| 16 | #MF | x87 FPU Error | No |
| 17 | #AC | Alignment Check | Yes |
| 18 | #MC | Machine Check | No |
| 19 | #XF | SIMD Floating-Point Error | No |

> ⚠️ **Error Codes**  
> Some exceptions push an extra **error code** onto the stack before jumping to the ISR. Your stub must account for this — the stack layout differs. A common fix: for exceptions without error codes, push a dummy `0` so your handler always receives a uniform stack.

---

## The 8259A PIC

The CPU has a single interrupt pin (`INTR`). Real hardware has many devices that need attention. The **Programmable Interrupt Controller (PIC)** — two cascaded **Intel 8259A** chips — multiplexes 15 hardware lines into that single pin.

```
  IRQ 0  (Timer)    ┐
  IRQ 1  (Keyboard) │
  IRQ 2  (Cascade)  │──► Master PIC (8259A) ──► CPU INTR
  IRQ 3  (COM2)     │         │
  IRQ 4  (COM1)     │         │ IRQ2 (cascade)
  IRQ 5  (LPT2)     │         ▼
  IRQ 6  (Floppy)   │   Slave PIC (8259A)
  IRQ 7  (LPT1)     ┘
                          IRQ 8  (RTC)
                          IRQ 9  (Open)
                          IRQ 10 (Open)
                          IRQ 11 (Open)
                          IRQ 12 (Mouse)
                          IRQ 13 (FPU)
                          IRQ 14 (Primary ATA)
                          IRQ 15 (Secondary ATA)
```

### The Remapping Problem

By default, the Master PIC maps IRQ 0–7 to vectors **0x08–0x0F**. This directly conflicts with Intel's reserved CPU exception vectors (0–31). 

**You must remap the PIC before enabling interrupts.** The standard remapping:
- IRQ 0–7  → vectors **32–39** (0x20–0x27)
- IRQ 8–15 → vectors **40–47** (0x28–0x2F)

### PIC I/O Ports

| PIC | Command Port | Data Port |
|-----|-------------|-----------|
| Master | `0x0020` | `0x0021` |
| Slave  | `0x00A0` | `0x00A1` |

### Remapping Sequence (Initialisation Command Words)

Remapping requires sending 4 **ICWs** to each PIC in sequence:

```
Step | Port          | Value  | Meaning
-----|---------------|--------|------------------------------------------
ICW1 | 0x20 / 0xA0  | 0x11   | Begin init; ICW4 will follow
ICW2 | 0x21          | 0x20   | Master: IRQ0 maps to vector 32 (0x20)
ICW2 | 0xA1          | 0x28   | Slave:  IRQ8 maps to vector 40 (0x28)
ICW3 | 0x21          | 0x04   | Master: slave is on IRQ2 (bit 2 set)
ICW3 | 0xA1          | 0x02   | Slave: connected to master's IRQ2
ICW4 | 0x21 / 0xA1  | 0x01   | 8086/88 mode
```

You must write these in order with a small I/O delay between each write.

### End-of-Interrupt (EOI)

After your ISR handles a hardware interrupt, you **must** send an **EOI** signal to the PIC. If you don't, the PIC will never raise that IRQ line again.

Send value `0x20` to the command port:

```
IRQ 0–7  (master only):  write 0x20 to port 0x20
IRQ 8–15 (slave + master): write 0x20 to port 0xA0, then 0x20 to port 0x20
```

### IRQ Masking

You can disable individual IRQ lines by writing a bitmask to the PIC's data port. A **1 bit = masked (disabled)**:

```
Master mask (port 0x21): bit 0 = IRQ0, bit 1 = IRQ1, ..., bit 7 = IRQ7
Slave mask  (port 0xA1): bit 0 = IRQ8, bit 1 = IRQ9, ..., bit 7 = IRQ15
```

Example — enable only keyboard (IRQ1), mask everything else on master:
```
0b11111101 → write to port 0x21
```

---

## The Interrupt Stack Frame

When an interrupt fires, the CPU automatically pushes the following onto the **kernel stack** (in this order, top to bottom):

```
  [SS]         ← only if privilege level changes (user → kernel)
  [ESP]        ← only if privilege level changes
  EFLAGS
  CS
  EIP          ← instruction to return to
  [Error Code] ← only for some exceptions
```

Your ISR runs with this on the stack. The `iret` instruction pops EIP, CS, and EFLAGS back to restore execution.

> ⚠️ **`iret` not `ret`**  
> ISRs must return with `iret`, not `ret`. Using `ret` would misinterpret the stack frame and almost certainly crash or corrupt state.

---

## Writing ISRs: The Assembly Stub Pattern

The CPU's interrupt mechanism doesn't use the C calling convention. You cannot write a plain `extern "C"` function and point the IDT at it — at least not without care. The standard approach is a thin **assembly stub** per vector:

```asm
isr_keyboard:
    pusha                    ; save all general-purpose registers
    call keyboard_handler    ; call your C++ function
    popa                     ; restore registers
    iret                     ; return from interrupt
```

For exceptions with error codes, the CPU has already pushed the error code. For those without, push a dummy 0 first so your C++ handler always receives the same stack layout.

In practice, you write a macro that generates these stubs automatically for all 256 vectors, to avoid writing them by hand.

---

## Full Interrupt Flow (Keyboard Example)

```
1. Key pressed
2. PIC: IRQ1 raised, not masked → signals CPU INTR pin with vector 33
3. CPU: finishes current instruction, IF=1 so interrupts enabled
4. CPU: pushes EFLAGS, CS, EIP onto stack
5. CPU: indexes IDT[33] → reads gate descriptor → jumps to stub
6. Stub: pusha, calls keyboard_handler()
7. Handler: reads scancode from port 0x60
8. Handler: sends EOI (0x20 → port 0x20)
9. Stub: popa, iret
10. CPU: pops EIP, CS, EFLAGS → resumes previous code
```

---

## Key Takeaways

- The IDT is a 256-entry table mapping interrupt vectors to ISR handler addresses
- Vectors 0–31 are CPU exceptions (Intel reserved); install handlers for all of them
- Hardware IRQs arrive through the 8259A PIC starting at vector 32 after remapping
- **Always remap the PIC** before enabling interrupts — default mapping conflicts with CPU exceptions
- After every hardware ISR, send EOI (`0x20`) to the appropriate PIC command port
- ISRs must return with `iret`, not `ret`
- Use assembly stubs to bridge the CPU's interrupt ABI to your C++ handlers
- Push a dummy error code (0) for exceptions that don't have one, to keep stack layout uniform

---

## Claude Code Prompt

> Use this prompt in Claude Code to implement this chapter.

```
Implement an Interrupt Descriptor Table (IDT) and PIC setup for our x86 32-bit OS.

Context:
- Bare-metal x86 OS with g++ (-m32, -nostdlib), GRUB multiboot
- GDT is already implemented (kernel CS selector = 0x0008)
- types.h provides uint8_t, uint16_t, uint32_t

Create the following files:

1. interrupts.h — Define:
   - InterruptHandler base class with virtual `HandleInterrupt(uint8_t interrupt, uint32_t esp)` returning uint32_t
   - InterruptManager class that:
     - Holds a 256-entry IDT (packed 8-byte gate descriptors)
     - Holds a 6-byte IDTR struct
     - Has a static InterruptManager* ActiveInterruptManager pointer
     - Constructor takes the PIC offset (use 0x20) and remaps the PIC via ICW1–ICW4
     - Installs all 256 IDT entries pointing to a default ignore handler
     - Installs specific handlers for IRQ0 (timer, vector 32) and IRQ1 (keyboard, vector 33)
     - Has Activate() / Deactivate() methods that call sti/cli
     - Static HandleInterrupt(uint8_t interrupt, uint32_t esp) called from ASM stubs

2. interrupts.cpp — Implementation:
   - PIC remapping in constructor (ICW1–ICW4 sequence to ports 0x20/0x21/0xA0/0xA1)
   - SetIdtEntry() helper to fill a gate descriptor (offset split into low/high 16 bits, selector=0x0008, type=0x8E for interrupt gate)
   - HandleInterrupt: send EOI (0x20 to 0x20, and if IRQ 8-15 also to 0xA0), return esp

3. interrupts.s — Assembly stubs:
   - One stub per vector for vectors 0x20 (IRQ0) and 0x21 (IRQ1), plus a default ignore stub
   - Each stub: pusha, push interrupt number, call InterruptManager::HandleInterrupt, popa, iret
   - Export all stub addresses as globals for interrupts.cpp to install into the IDT

4. Wire into kernelMain: construct InterruptManager, call Activate().
   Add interrupts.o to makefile.

Use I/O port access via inline asm or a Port class (inline `outb`/`inb` with `__asm__ volatile`).
All structs must be __attribute__((packed)).
```
