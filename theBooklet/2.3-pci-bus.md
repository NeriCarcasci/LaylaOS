# Chapter 2.3 — PCI Bus Enumeration

---

## What is PCI?

**Peripheral Component Interconnect (PCI)** is the standard bus that connects hardware devices to the CPU and each other — network cards, graphics cards, storage controllers, USB controllers, sound cards. To write drivers for any of these, you first need to discover what's actually present in the system.

PCI enumeration is how your OS asks: *"what hardware is installed?"*

---

## PCI Address Space

PCI devices are identified by three coordinates:

```
Bus  (0–255)   — which PCI bus (most systems only use bus 0)
Device (0–31)  — slot on that bus
Function (0–7) — sub-function within the device (e.g. audio + MIDI on same chip)
```

Together: `(bus, device, function)` — often written **B:D.F** (e.g. `00:1F.2`).

Each device has a **256-byte configuration space** — a standardised set of registers describing what the device is and how to communicate with it.

---

## The PCI Configuration Mechanism (Type 1)

On x86, you access PCI configuration space through two I/O ports:

| Port | Name | Direction |
|------|------|-----------|
| `0x0CF8` | CONFIG_ADDRESS | Write |
| `0x0CFC` | CONFIG_DATA | Read / Write |

To read a dword from a device's config space:

1. Write a 32-bit **address** to `0x0CF8`:
```
bit 31    = Enable bit (must be 1)
bits 23:16 = Bus number
bits 15:11 = Device number
bits 10:8  = Function number
bits 7:2   = Register offset (which dword in config space)
bits 1:0   = 0 (must be aligned)
```

2. Read 4 bytes from `0x0CFC` — this returns that dword from the device's config space.

```cpp
uint32_t pci_read(uint8_t bus, uint8_t device, uint8_t func, uint8_t offset) {
    uint32_t address = (1 << 31)
                     | ((uint32_t)bus    << 16)
                     | ((uint32_t)device << 11)
                     | ((uint32_t)func   << 8)
                     | (offset & 0xFC);
    outl(0x0CF8, address);
    return inl(0x0CFC);
}
```

---

## PCI Configuration Space Layout

The first 64 bytes (0x00–0x3F) are the **common header**, present on all devices:

```
Offset  Size  Field
0x00    2     Vendor ID      — who made this device (0xFFFF = no device present)
0x02    2     Device ID      — what device it is
0x04    2     Command        — enables memory/IO space, bus mastering
0x06    2     Status         — device status flags
0x08    1     Revision ID
0x09    1     Prog IF        — programming interface subtype
0x0A    1     Subclass       — device subclass
0x0B    1     Class Code     — device class (see below)
0x0C    1     Cache Line Size
0x0D    1     Latency Timer
0x0E    1     Header Type    — 0x00 = standard, 0x01 = PCI-to-PCI bridge
0x0F    1     BIST
0x10–0x27  6×4  BAR 0–5     — Base Address Registers (where device memory is mapped)
0x28    4     CardBus CIS Pointer
0x2C    2     Subsystem Vendor ID
0x2E    2     Subsystem ID
0x30    4     Expansion ROM Base Address
0x34    1     Capabilities Pointer
0x3C    1     Interrupt Line  — which IRQ line this device uses
0x3D    1     Interrupt Pin   — which INT pin (INTA–INTD)
```

---

## Device Class Codes

The **Class Code** (offset 0x0B) tells you what kind of device it is:

| Class | Description |
|-------|-------------|
| `0x00` | Unclassified |
| `0x01` | Mass Storage Controller (HDD, etc.) |
| `0x02` | Network Controller |
| `0x03` | Display Controller (GPU) |
| `0x04` | Multimedia Controller |
| `0x06` | Bridge Device (PCI-to-PCI, ISA, etc.) |
| `0x0C` | Serial Bus Controller (USB, FireWire) |

Combined with the **Subclass** and **Prog IF**, you can identify exactly what a device is and which driver it needs.

---

## Enumerating the Bus

Enumeration is simple brute force — iterate every possible `(bus, device, function)` combination, read vendor ID, check if it's `0xFFFF` (no device):

```
for bus in 0..255:
  for device in 0..31:
    for function in 0..7:
      vendor = pci_read(bus, device, function, 0x00) & 0xFFFF
      if vendor == 0xFFFF:
        continue   // nothing here
      // device found — read class, subclass, device ID, etc.
      // store in a device list
      
      // check header type — if not multi-function, skip other functions
      header_type = pci_read(bus, device, function, 0x0E)
      if function == 0 and not (header_type & 0x80):
        break
```

In practice you only iterate buses 0–7 on most desktop systems.

---

## Base Address Registers (BARs)

BARs (offsets 0x10–0x27) tell you where the device's memory or I/O regions are mapped. You'll need these when writing individual device drivers (e.g. to find where a network card's registers live in memory).

A BAR can be either:
- **I/O space BAR** — bit 0 = 1. Bits 31:2 = I/O port base address.
- **Memory space BAR** — bit 0 = 0. Bits 31:4 = memory-mapped base address.

To find the **size** of a BAR region:
1. Save the original BAR value
2. Write `0xFFFFFFFF` to the BAR
3. Read back the value
4. Restore original value
5. Mask off the type bits and invert: `size = ~(value & mask) + 1`

This is the **BAR sizing algorithm** — we'll cover it in detail in the driver abstractions chapter.

---

## Vendor & Device ID Reference (Common Devices)

| Vendor ID | Vendor |
|-----------|--------|
| `0x8086` | Intel |
| `0x10DE` | NVIDIA |
| `0x1022` | AMD |
| `0x10EC` | Realtek |
| `0x1234` | QEMU virtual devices |

When running in QEMU, you'll commonly see:
- `0x1234:0x1111` — QEMU VGA
- `0x8086:0x100E` — Intel e1000 network (QEMU default NIC)
- `0x1AF4:...` — VirtIO devices

---

## Key Takeaways

- PCI devices are identified by Bus:Device.Function coordinates
- Access PCI configuration space via port pair `0x0CF8` (address) / `0x0CFC` (data)
- The address written to `0x0CF8` must have bit 31 set as an enable bit
- Enumerate by iterating all B:D:F and checking for `VendorID == 0xFFFF` (no device)
- Class code + Subclass identifies what kind of device you've found
- BARs tell you where the device's registers are in memory or I/O space
- You need PCI enumeration as a prerequisite to writing any device driver (NIC, GPU, HDD)

---

## Claude Code Prompt

> Use this prompt in Claude Code to implement this chapter.

```
Implement a PCI bus enumerator for our x86 32-bit OS.

Context:
- Bare-metal x86 OS with g++ (-m32, -nostdlib, -fno-exceptions, -fno-rtti)
- Port32Bit class available from port.h (Read() / Write() methods) for 32-bit port access
- types.h provides uint8_t, uint16_t, uint32_t

Create the following files:

1. pci.h — Define:
   - PCIDeviceDescriptor struct: bus, device, function, vendor_id, device_id,
     class_id, subclass_id, interface_id, revision, interrupt, port_base[6], mem_base[6]
   - PeripheralComponentInterconnect class with:
     - Constructor takes no args
     - uint32_t Read(uint16_t bus, uint16_t device, uint16_t function, uint32_t registeroffset)
     - void Write(uint16_t bus, uint16_t device, uint16_t function, uint32_t registeroffset, uint32_t value)
     - bool DeviceHasFunctions(uint16_t bus, uint16_t device)
     - PCIDeviceDescriptor GetDeviceDescriptor(uint16_t bus, uint16_t device, uint16_t function)
     - void SelectDrivers() — enumerates all buses/devices/functions, prints found devices to VGA

2. pci.cpp — Implementation:
   - Read(): construct address = (1<<31) | (bus<<16) | (device<<11) | (function<<8) | (offset & 0xFC)
     Write to port 0xCF8, read from 0xCFC, shift result by (offset & 3)*8
   - Write(): same address construction, write value to 0xCFC
   - DeviceHasFunctions(): check bit 7 of header type byte (offset 0x0E)
   - GetDeviceDescriptor(): populate struct from config space reads
   - SelectDrivers(): nested loops over bus 0..7, device 0..31, function 0..7
     Skip if vendor == 0xFFFF; print "PCI [class:subclass] vendor:device" for each found device

Wire SelectDrivers() call into kernelMain after the InterruptManager is set up.
Use Port32Bit for all config space access (ports 0xCF8 and 0xCFC).
Add pci.o to the makefile.
```
