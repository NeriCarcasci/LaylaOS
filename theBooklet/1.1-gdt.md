# Chapter 1.1 — The Global Descriptor Table (GDT)

---

## Why Does the GDT Exist?

When Intel designed the 80286, they introduced **Protected Mode** — a CPU operating mode where programs can't freely trample each other's memory or execute privileged instructions. The mechanism they chose was **memory segmentation**.

The core idea: every memory access goes through a **segment**. A segment is a window into RAM described by:

- A **base address** — where in RAM the segment starts
- A **limit** — how large the segment is
- **Access flags** — who can use it, and how (read, write, execute)

The CPU stores these segment descriptions in a table in RAM called the **Global Descriptor Table (GDT)**.

> **Why "global"?**  
> There are two descriptor tables: the **GDT** (global, one per system) and the **LDT** (local, one per process). Modern OSes almost exclusively use the GDT. Linux and Windows both use a flat model through the GDT and largely ignore the LDT.

---

## Segmentation vs. Paging

Two terms you'll hear for memory protection in x86 — they are different things operating at different stages:

```
Logical Address          Linear Address           Physical Address
(segment : offset)  -->  (flat 32-bit)       -->  (actual RAM byte)
               [GDT translates]         [Page Tables translate]
```

1. The CPU takes a **logical address** (a segment register + an offset)
2. The **GDT** adds the segment base, checks against the limit → produces a **linear address**
3. If paging is enabled, **page tables** translate linear → **physical**

Most modern OSes use a **flat memory model**: GDT segments are set with base=0 and limit=4GB, so the logical address equals the linear address. The GDT becomes a mandatory formality — but it *is* mandatory. The CPU will not enter protected mode without one.

---

## Structure of a GDT Entry

Each entry in the GDT is exactly **8 bytes (64 bits)**. The layout is notoriously non-intuitive — Intel split the fields across non-contiguous bits for backwards-compatibility with the 286.

```
Bit:  63      56 55 54 53 52 51    48 47 46 45 44 43    40 39    32
      +--------+--+--+--+--+--------+--+-----+--+--------+--------+
      |Base    |G |D |L |A |Limit   |P |DPL  |S |Type    |Base    |
      |[31:24] |  |/B|  |VL|[19:16] |  |     |  |        |[23:16] |
      +--------+--+--+--+--+--------+--+-----+--+--------+--------+

Bit:  31                          16 15                           0
      +----------------------------+------------------------------+
      |    Base Address [15:0]     |       Limit [15:0]           |
      +----------------------------+------------------------------+
```

| Bits  | Field        | Meaning |
|-------|--------------|---------|
| 0–15  | Limit[0:15]  | Lower 16 bits of the segment limit |
| 16–31 | Base[0:15]   | Lower 16 bits of the base address |
| 32–39 | Base[16:23]  | Next 8 bits of base address |
| 40–43 | Type         | Segment type (code/data, readable, writable…) |
| 44    | S            | 0 = system segment, 1 = code/data segment |
| 45–46 | DPL          | Descriptor Privilege Level (0=kernel, 3=user) |
| 47    | P            | Present — must be 1 for a valid segment |
| 48–51 | Limit[16:19] | Upper 4 bits of limit |
| 52    | AVL          | Available for OS use (we ignore it) |
| 53    | L            | 1 = 64-bit code segment (long mode — we don't use this) |
| 54    | D/B          | 1 = 32-bit segment, 0 = 16-bit |
| 55    | G            | Granularity: 0 = limit in bytes, 1 = limit in 4KB pages |
| 56–63 | Base[24:31]  | Highest 8 bits of base address |

> ⚠️ **The split fields are intentional and annoying.**  
> The base address and limit are each split across non-contiguous ranges. In code you'll construct entries by manually ORing shifted values. This is normal — every OS does it this way.

---

## The Descriptor Privilege Level (DPL)

The **DPL** is a 2-bit field — four possible **rings**:

```
          ┌──────────────────────────────┐
          │  Ring 0  (Kernel)            │  ← most privileged
          │  ┌────────────────────────┐  │
          │  │  Ring 1  (unused)      │  │
          │  │  ┌──────────────────┐  │  │
          │  │  │  Ring 2 (unused) │  │  │
          │  │  │  ┌────────────┐  │  │  │
          │  │  │  │  Ring 3   │  │  │  │
          │  │  │  │  (User)   │  │  │  │  ← least privileged
          │  │  │  └────────────┘  │  │  │
          │  │  └──────────────────┘  │  │
          │  └────────────────────────┘  │
          └──────────────────────────────┘
```

In practice:
- **Ring 0** — your kernel. Can do anything.
- **Ring 3** — user programs (we'll add this later).
- Rings 1 & 2 — almost never used in modern OSes.

Executing a privileged instruction from Ring 3 triggers a **General Protection Fault (#GP)**.

---

## Minimum Required GDT

Every protected-mode OS needs at minimum **three entries**:

| Index | Selector  | Name            | Base       | Limit      | Ring |
|-------|-----------|-----------------|------------|------------|------|
| 0     | `0x0000`  | Null Descriptor | —          | —          | —    |
| 1     | `0x0008`  | Kernel Code     | 0x00000000 | 0xFFFFFFFF | 0    |
| 2     | `0x0010`  | Kernel Data     | 0x00000000 | 0xFFFFFFFF | 0    |

**The null descriptor** (index 0) must always be present and completely zeroed. Loading a null selector into a segment register is allowed, but any memory access through it will fault.

---

## Segment Selectors

When you want to use a GDT entry, you load its **selector** into a segment register (`CS`, `DS`, `ES`, `SS`, etc.). A selector is a 16-bit value:

```
 15                  3   2   1   0
 ┌───────────────────┬───┬───────┐
 │  GDT Index        │TI │  RPL  │
 │  (which entry)    │0=G│(priv) │
 └───────────────────┴───┴───────┘
```

- **Index**: which GDT entry (multiply by 8 to get byte offset)
- **TI**: Table Indicator — 0 = GDT, 1 = LDT
- **RPL**: Requested Privilege Level

So:
- Kernel code segment (index 1): selector = `1 × 8 = 0x0008`
- Kernel data segment (index 2): selector = `2 × 8 = 0x0010`

---

## The GDTR Register

The CPU doesn't know where the GDT is in RAM until you tell it. You do this by loading the **GDTR** (GDT Register) using the `lgdt` instruction. It takes a 6-byte descriptor:

```
 47                              16 15             0
 ┌──────────────────────────────────┬───────────────┐
 │   Base Address (32-bit)          │  Limit (16-bit)│
 │   Physical address of GDT        │  sizeof(GDT)-1 │
 └──────────────────────────────────┴───────────────┘
```

After `lgdt`, you **must** perform a **far jump** to reload `CS` with the new kernel code selector:

```asm
lgdt [gdtr]
jmp 0x08:flush_cs    ; far jump: loads CS = 0x08 (kernel code selector)
flush_cs:
mov ax, 0x10         ; kernel data selector
mov ds, ax
mov es, ax
mov fs, ax
mov gs, ax
mov ss, ax
```

Until this far jump happens, the CPU still uses its old segment state.

---

## The `__attribute__((packed))` Requirement

When defining GDT structs in C++, the compiler will add padding between fields by default. This would break the 8-byte layout entirely. You **must** use `__attribute__((packed))` on every GDT-related struct.

```cpp
struct GdtEntry {
    uint16_t limit_low;
    uint16_t base_low;
    uint8_t  base_mid;
    uint8_t  access;
    uint8_t  granularity;   // limit_high[3:0] | flags[7:4]
    uint8_t  base_high;
} __attribute__((packed));
```

---

## Encoding a Flat Segment (worked example)

For a kernel code segment: base=0, limit=4GB, Ring 0, executable, 32-bit, 4KB granularity.

| Field       | Value  | Reason |
|-------------|--------|--------|
| base        | 0      | flat model |
| limit       | 0xFFFFF | with G=1 this covers 4GB |
| G           | 1      | granularity in 4KB pages |
| D/B         | 1      | 32-bit segment |
| P           | 1      | segment present |
| DPL         | 0      | Ring 0 |
| S           | 1      | code/data (not system) |
| Type        | 0xA    | code, readable, not conforming |

Access byte = `P(1) | DPL(00) | S(1) | Type(1010)` = `0b10011010` = `0x9A`  
Granularity byte = `G(1) | D(1) | L(0) | AVL(0) | Limit[19:16](1111)` = `0b11001111` = `0xCF`

---

## Key Takeaways

- The GDT is a table in RAM describing memory segments — mandatory in protected mode
- Each entry is exactly 8 bytes with a split, non-intuitive layout
- Minimum entries: null descriptor, kernel code, kernel data
- Load the GDT with `lgdt` then immediately do a far jump to reload `CS`
- For a flat model: base=0, limit=0xFFFFF, G=1 (covers all 4GB)
- Selectors = `(index × 8) | privilege_level`
- Always use `__attribute__((packed))` on GDT structs

---

## Claude Code Prompt

> Use this prompt in Claude Code to implement this chapter.

```
Implement a Global Descriptor Table (GDT) for our x86 32-bit OS kernel.

Context:
- This is a bare-metal x86 OS built with g++ (-m32, -nostdlib) and GRUB multiboot
- We already have: loader.s (multiboot entry), kernel.cpp (kernelMain), types.h, linker.ld
- The kernel is loaded at 0x100000 and starts in 32-bit protected mode via GRUB

Create the following files:

1. gdt.h — GdtEntry struct (packed, 8 bytes), GdtDescriptor struct (packed, 6 bytes for lgdt),
   and a GlobalDescriptorTable class with:
   - Constructor that sets up 3 entries: null, kernel code (0x9A / 0xCF), kernel data (0x92 / 0xCF)
   - All segments flat: base=0, limit=0xFFFFF, G=1

2. gdt.cpp — Implementation of the GlobalDescriptorTable constructor.
   Encode each entry manually from base/limit/access/granularity fields.

3. gdt.s — Assembly stub with a global function `gdt_flush(uint32_t gdtr_ptr)` that:
   - Calls lgdt [eax]
   - Does a far jump to reload CS with selector 0x08
   - Loads 0x10 into DS, ES, FS, GS, SS

Wire it into kernelMain: construct a GlobalDescriptorTable, call gdt_flush.
Add gdt.o to the makefile objects list.

Use the types from types.h (uint8_t, uint16_t, uint32_t).
All structs must be __attribute__((packed)).
```
