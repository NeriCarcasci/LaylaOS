# Chapter 2.2 — PS/2 Keyboard & Mouse

---

## The Intel 8042 PS/2 Controller

The keyboard and (in legacy mode) the mouse don't talk directly to the CPU. They communicate via the **Intel 8042 microcontroller**, a dedicated chip that sits between the CPU and the physical devices. It handles the serial PS/2 protocol and presents a simple byte-based interface via I/O ports.

```
  ┌──────────┐    PS/2 cable    ┌───────────────┐    I/O ports     ┌─────┐
  │ Keyboard │ ◄──────────────► │  8042 PS/2    │ ◄──────────────► │ CPU │
  │  (PS/2)  │                  │  Controller   │                  │     │
  └──────────┘                  │               │                  └─────┘
  ┌──────────┐    PS/2 cable    │               │
  │  Mouse   │ ◄──────────────► │               │
  │  (PS/2)  │                  └───────────────┘
  └──────────┘
```

### I/O Ports

| Port | Access | Register |
|------|--------|----------|
| `0x60` | Read  | Data buffer — byte from keyboard or mouse |
| `0x60` | Write | Data to send to keyboard or mouse |
| `0x64` | Read  | Status register |
| `0x64` | Write | Command to the 8042 controller itself |

### Status Register (read from `0x64`)

| Bit | Name | Meaning when set (1) |
|-----|------|----------------------|
| 0 | OBF | Output Buffer Full — data is ready to read from `0x60` |
| 1 | IBF | Input Buffer Full — controller busy, don't write yet |
| 2 | SYS | System flag (set after successful self-test) |
| 3 | A2  | Last write was to `0x64` (command) vs `0x60` (data) |
| 4 | INH | 0 = keyboard inhibited |
| 5 | MOBF | Mouse output buffer full |
| 6 | TO  | Timeout error |
| 7 | PERR | Parity error |

**Always check OBF before reading, and IBF before writing.**

---

## Keyboard: Scancodes

When a key is pressed or released, the 8042 places a **scancode** in the data buffer and fires **IRQ1**. Your keyboard ISR reads this byte from port `0x60`.

### Scancode Sets

There are three scancode sets. The 8042 defaults to **Scancode Set 2**, but usually translates it to **Scancode Set 1** automatically. Set 1 is what you'll typically receive.

### Scancode Set 1 — Make & Break Codes

- **Make code** — sent when a key is **pressed** (value `< 0x80`)
- **Break code** — sent when a key is **released** (make code `| 0x80`)

```
Key 'A' pressed  → scancode 0x1E
Key 'A' released → scancode 0x9E  (= 0x1E | 0x80)
```

### Scancode → ASCII Lookup Table

You convert scancodes to characters using a lookup table. You'll need at least two:
- A **normal** table (no modifier)
- A **shifted** table (when Shift is held)

```
Scancode Set 1 — selected entries (make codes):

0x01 = Escape      0x0E = Backspace   0x1C = Enter
0x02 = '1'         0x0F = Tab         0x1D = Left Ctrl
0x03 = '2'         0x10 = 'q'         0x2A = Left Shift
0x04 = '3'         0x11 = 'w'         0x36 = Right Shift
0x05 = '4'         0x12 = 'e'         0x38 = Left Alt
0x06 = '5'         0x1E = 'a'         0x39 = Space
0x07 = '6'         0x1F = 's'
...
```

### Tracking Modifier Keys

Your handler must track modifier state as a set of flags:

```cpp
bool shift_pressed = false;
bool ctrl_pressed  = false;
bool alt_pressed   = false;
bool caps_lock     = false;
```

On each IRQ1:
1. Read scancode from `0x60`
2. If `scancode >= 0x80` → it's a break code, `scancode -= 0x80`, mark key as released
3. Check if it's a modifier key (Shift, Ctrl, Alt, CapsLock) and update flags
4. Otherwise look up in the appropriate table and emit the character

---

## Mouse: The PS/2 Protocol

The mouse is on the **second PS/2 port**, controlled by the same 8042 chip. By default, the mouse is disabled — you must explicitly enable it.

### Enabling the Mouse

All mouse communication goes through the 8042 using controller commands (write to `0x64`):

```
Step 1: Enable auxiliary device
  outb(0x64, 0xA8)

Step 2: Enable mouse IRQ (IRQ12) by setting bit 1 of the 8042 command byte
  outb(0x64, 0x20)         // get command byte
  byte = inb(0x60)
  byte |= 0x02             // set AUX IRQ enable bit
  outb(0x64, 0x60)         // set command byte
  outb(0x60, byte)

Step 3: Send "enable data reporting" command to mouse itself
  outb(0x64, 0xD4)         // tell 8042: next byte goes to mouse
  outb(0x60, 0xF4)         // mouse command: enable data reporting
  inb(0x60)                // read ACK (should be 0xFA)
```

### Mouse Data Packets

When the mouse moves or a button is clicked, it sends a **3-byte packet** (or 4 bytes for scroll-wheel mice):

```
Byte 0 (flags):
  bit 7: Y overflow
  bit 6: X overflow
  bit 5: Y sign (1 = negative, moving up)
  bit 4: X sign (1 = negative, moving left)
  bit 3: Always 1
  bit 2: Middle button
  bit 1: Right button
  bit 0: Left button

Byte 1: X movement (signed, 9-bit with sign from byte 0 bit 4)
Byte 2: Y movement (signed, 9-bit with sign from byte 0 bit 5)
```

The mouse fires **IRQ12** once for every byte. So you receive **three separate interrupts** per packet and must reassemble them:

```
IRQ12 fires → read byte 0 (flags)
IRQ12 fires → read byte 1 (X delta)
IRQ12 fires → read byte 2 (Y delta)
→ now process the complete packet
```

Use a `mouse_cycle` counter (0, 1, 2) to track where you are in the packet.

### Sending Data to Mouse vs Controller

The 8042 has two channels. To send a command to the **controller itself**, write to `0x64`. To send a byte to the **mouse**, first tell the controller by writing `0xD4` to `0x64`, then write the data byte to `0x60`.

> ⚠️ **Always wait for IBF to clear before writing.**  
> Spin on `inb(0x64) & 0x02` until it's zero before sending each byte.

---

## IRQ Routing

| Device | IRQ | Vector (after PIC remap) |
|--------|-----|--------------------------|
| Keyboard | IRQ1 | 33 (0x21) |
| Mouse | IRQ12 | 44 (0x2C) |

Both map through the PIC — keyboard is on the master, mouse is on the slave. Remember: for IRQ12 you must send EOI to both the slave (`0xA0`) and then the master (`0x20`).

---

## Key Takeaways

- The Intel 8042 sits between the CPU and PS/2 devices; you talk to it via ports `0x60`/`0x64`
- Always check the status register before reading or writing
- Keyboard sends scancodes; make codes = key pressed, break codes = `make | 0x80`
- Build a scancode-to-ASCII lookup table and track modifier state (Shift, Ctrl, Alt, CapsLock)
- Mouse must be explicitly enabled via 8042 controller commands
- Mouse sends 3-byte packets, one byte per IRQ12 — use a cycle counter to reassemble
- To send to the mouse: write `0xD4` to `0x64`, then data byte to `0x60`
- Mouse IRQ12 is on the slave PIC — send EOI to slave then master

---

## Claude Code Prompt

> Use this prompt in Claude Code to implement this chapter.

```
Implement PS/2 keyboard and mouse drivers for our x86 32-bit OS.

Context:
- Bare-metal x86 OS with g++ (-m32, -nostdlib, -fno-exceptions, -fno-rtti)
- Port8Bit class available from port.h (Read() / Write() methods)
- InterruptManager and InterruptHandler base class available from interrupts.h
- types.h provides uint8_t, uint16_t, uint32_t

Create the following files:

1. keyboard.h / keyboard.cpp — KeyboardDriver class:
   - Inherits from InterruptHandler, handles vector 0x21 (IRQ1)
   - Constructor takes InterruptManager* and registers itself
   - HandleInterrupt() reads scancode from port 0x60
   - Maintains shift/caps state from modifier scancodes
   - Translates scancode to ASCII using two lookup tables (normal + shifted)
   - Calls a virtual void OnKeyPress(char c) method — override to handle input
   - Prints the character to VGA (use the existing printf-style VGA write at 0xB8000)

2. mouse.h / mouse.cpp — MouseDriver class:
   - Inherits from InterruptHandler, handles vector 0x2C (IRQ12)
   - Constructor takes InterruptManager*, enables the mouse by:
     a. Sending 0xA8 to port 0x64 (enable aux)
     b. Reading/modifying/writing the 8042 command byte to enable IRQ12
     c. Sending 0xD4 → 0x64, then 0xF4 → 0x60 to enable mouse reporting
     d. Reading the 0xFA ACK
   - HandleInterrupt() reassembles 3-byte packets using a cycle counter
   - Tracks x, y position (clamp to 0–319, 0–199)
   - Calls virtual void OnMouseMove(int x, int y, bool left, bool right, bool middle)
   - Default implementation draws a pixel at (x,y) on VGA

Wire both drivers into kernelMain after the InterruptManager is set up.
Add keyboard.o and mouse.o to the makefile.

Wait for IBF (bit 1 of status port 0x64) to clear before each write to the controller.
Send EOI for IRQ12 to slave (0xA0) then master (0x20).
```
