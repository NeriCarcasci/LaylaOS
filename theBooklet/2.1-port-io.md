# Chapter 2.1 â€” Port I/O

---

## The I/O Address Space

x86 has **two separate address spaces**:

- **Memory space** â€” accessed with normal load/store instructions (`mov`, `push`, `pop`, etc.)
- **I/O port space** â€” accessed with special `in`/`out` instructions

The I/O space is 16-bit wide: 65,536 possible ports (`0x0000`â€“`0xFFFF`). Hardware devices expose their internal registers through specific port addresses. These assignments are part of the PC hardware standard â€” you don't allocate them dynamically, they are fixed by convention.

```
Port 0x0020â€“0x0021 â†’ Master PIC
Port 0x0040â€“0x0043 â†’ PIT (Programmable Interval Timer)
Port 0x0060, 0x0064 â†’ PS/2 Keyboard & Mouse Controller
Port 0x0070â€“0x0071 â†’ CMOS / Real-Time Clock
Port 0x00A0â€“0x00A1 â†’ Slave PIC
Port 0x01F0â€“0x01F7 â†’ Primary ATA hard drive
Port 0x03F8â€“0x03FF â†’ COM1 (Serial port)
Port 0x0CF8â€“0x0CFF â†’ PCI Configuration Space
```

---

## The `in` and `out` Instructions

```asm
; Read 1 byte from port 0x60 into AL
in  al, 0x60

; Write 1 byte from AL to port 0x20
out 0x20, al

; For variable port addresses, use DX:
mov dx, 0x01F0
in  ax, dx       ; Read 2 bytes (word)
out dx, eax      ; Write 4 bytes (dword)
```

The operand sizes map to instruction variants:

| C++ name | ASM instruction | Transfer size |
|----------|----------------|---------------|
| `inb` / `outb` | `in al` / `out al` | 8-bit (byte) |
| `inw` / `outw` | `in ax` / `out ax` | 16-bit (word) |
| `inl` / `outl` | `in eax` / `out eax` | 32-bit (dword) |

---

## Using Port I/O from C++

C++ has no built-in port I/O. You access it through **inline assembly** using GCC's `__asm__ volatile` syntax:

```cpp
static inline uint8_t inb(uint16_t port) {
    uint8_t result;
    __asm__ volatile ("inb %1, %0" : "=a"(result) : "Nd"(port));
    return result;
}

static inline void outb(uint16_t port, uint8_t value) {
    __asm__ volatile ("outb %0, %1" : : "a"(value), "Nd"(port));
}
```

The GCC constraint characters:
- `"=a"` â€” output goes into `AL`/`AX`/`EAX`
- `"a"` â€” input comes from `AL`/`AX`/`EAX`
- `"Nd"` â€” port number: immediate if it fits in 8 bits, otherwise `DX`
- `volatile` â€” prevents the compiler from reordering or optimising away the instruction

---

## The I/O Wait

On some hardware â€” especially older machines, or when writing to slow I/O devices â€” you need a brief delay after a write before the next operation. The traditional trick:

```cpp
static inline void io_wait() {
    outb(0x80, 0);   // port 0x80 is unused (POST diagnostic port)
}
```

Writing to port `0x80` (a POST code port that exists but does nothing useful) wastes approximately 1â€“4 microseconds. It's used throughout the PIC remapping sequence where ICWs must arrive with slight spacing.

> ðŸ’¡ On modern hardware this is nearly instant and mostly harmless, but we include it for correctness â€” especially since PIC initialisation is sensitive to timing.

---

## Design: A Port Class

Rather than scattering raw `inb`/`outb` calls throughout your codebase, you'll build a **Port abstraction** that every driver uses. This is the foundation of your hardware communication layer.

The cleanest approach in C++ is to template on width:

```
Port<uint8_t>  â†’ uses inb / outb
Port<uint16_t> â†’ uses inw / outw
Port<uint32_t> â†’ uses inl / outl
```

Each Port object holds a port number and exposes `Read()` / `Write()` methods. Every driver receives Port objects in its constructor rather than hardcoding port numbers, which also makes testing easier.

```cpp
// Example usage from a driver:
Port<uint8_t>  dataPort(0x60);
Port<uint8_t>  cmdPort(0x64);

uint8_t status = cmdPort.Read();
dataPort.Write(0xF4);  // enable keyboard scanning
```

---

## Key Takeaways

- x86 has a separate 16-bit I/O address space accessed via `in`/`out` instructions
- Port addresses for hardware devices are fixed by the PC standard â€” not dynamically allocated
- In C++ you access ports via `__asm__ volatile` inline assembly with GCC constraints
- Always use `volatile` to prevent the compiler from optimising away port accesses
- Add an `io_wait()` (write to port 0x80) when dealing with slow hardware like the PIC
- Build a Port class as your hardware abstraction foundation â€” every driver builds on top of it

---

## Claude Code Prompt

> Use this prompt in Claude Code to implement this chapter.

```
Implement a Port I/O abstraction layer for our x86 32-bit OS.

Context:
- Bare-metal x86 OS with g++ (-m32, -nostdlib, -fno-exceptions, -fno-rtti)
- types.h provides uint8_t, uint16_t, uint32_t

Create port.h (header only, no .cpp needed):

1. Three concrete classes: Port8Bit, Port16Bit, Port32Bit
   Each takes a uint16_t port number in its constructor.
   Each has Read() and Write(value) methods using inline asm.

2. Inline assembly:
   - Port8Bit::Read()  â†’ `inb`  instruction, constraint "=a" / "Nd"
   - Port8Bit::Write() â†’ `outb` instruction, constraint "a" / "Nd"
   - Port16Bit uses `inw`/`outw`
   - Port32Bit uses `inl`/`outl`
   - All marked __asm__ volatile

3. A free function `io_wait()` that writes 0 to port 0x80.

4. A Port8BitSlow subclass of Port8Bit whose Write() calls io_wait() 
   after every write â€” used for PIC and other slow devices.

All methods should be inline (defined in header).
No dynamic allocation, no STL, no exceptions.
```
